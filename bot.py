import discord
from discord.ext import commands
from datetime import datetime, timezone
import random
import os
from dotenv import load_dotenv
import asyncio
import logging
import db

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Charger les variables d'environnement
load_dotenv()

# Variables d'environnement
TOKEN = os.getenv("DISCORD_TOKEN")
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL")
PREFIX = os.getenv("PREFIX", "!")

# V√©rification des variables critiques
if not TOKEN:
    logger.error("‚ùå DISCORD_TOKEN manquant dans le fichier .env")
    exit(1)

if not DATABASE_URL:
    logger.error("‚ùå DATABASE_URL manquant dans le fichier .env")
    exit(1)

# Configuration des intents
intents = discord.Intents.default()
intents.message_content = True  # N√©cessaire pour les commandes pr√©fix√©es
intents.guilds = True
intents.guild_messages = True

# Initialisation du bot
bot = commands.Bot(command_prefix=PREFIX, intents=intents, help_command=None)
database = db.Database(dsn=DATABASE_URL)

@bot.event
async def on_ready():
    """√âv√©nement d√©clench√© quand le bot est pr√™t"""
    logger.info(f"‚úÖ {bot.user} est connect√© et pr√™t !")
    logger.info(f"üìä Connect√© √† {len(bot.guilds)} serveur(s)")
    
    try:
        await database.connect()
        logger.info("‚úÖ Base de donn√©es connect√©e avec succ√®s")
    except Exception as e:
        logger.error(f"‚ùå Erreur de connexion √† la base de donn√©es: {e}")

@bot.event
async def on_command_error(ctx, error):
    """Gestion globale des erreurs de commandes"""
    if isinstance(error, commands.CommandNotFound):
        return  # Ignorer les commandes inexistantes
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send(f"‚ùå **Argument manquant !**\nUtilise `{PREFIX}help` pour voir l'aide.")
    elif isinstance(error, commands.BadArgument):
        await ctx.send(f"‚ùå **Argument invalide !**\nUtilise `{PREFIX}help` pour voir l'aide.")
    elif isinstance(error, commands.CommandOnCooldown):
        await ctx.send(f"‚è∞ **Cooldown !** R√©essaye dans {error.retry_after:.1f} secondes.")
    elif isinstance(error, commands.MissingPermissions):
        await ctx.send("‚ùå **Tu n'as pas les permissions n√©cessaires !**")
    else:
        logger.error(f"Erreur non g√©r√©e dans {ctx.command}: {error}")
        await ctx.send("‚ùå **Une erreur inattendue s'est produite.**")

# ==================== COMMANDES √âCONOMIE ====================

@bot.command(name='balance', aliases=['bal', 'money'])
async def balance_cmd(ctx, member: discord.Member = None):
    """Affiche le solde d'un utilisateur"""
    target = member or ctx.author
    
    try:
        balance = await database.get_balance(target.id)
        
        embed = discord.Embed(
            title="üí∞ Solde",
            description=f"**{target.display_name}** poss√®de **{balance:,}** pi√®ces",
            color=0x00ff00 if balance > 0 else 0xff9900
        )
        embed.set_thumbnail(url=target.display_avatar.url)
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        logger.error(f"Erreur balance pour {target.id}: {e}")
        await ctx.send("‚ùå **Erreur lors de la r√©cup√©ration du solde.**")

@bot.command(name='give', aliases=['pay', 'transfer'])
@commands.cooldown(1, 5, commands.BucketType.user)  # 1 fois par 5 secondes
async def give_cmd(ctx, member: discord.Member, amount: int):
    """Donne des pi√®ces √† un autre utilisateur"""
    giver = ctx.author
    receiver = member
    
    # Validations
    if amount <= 0:
        await ctx.send("‚ùå **Le montant doit √™tre positif !**")
        return
        
    if giver.id == receiver.id:
        await ctx.send("‚ùå **Tu ne peux pas te donner des pi√®ces √† toi-m√™me !**")
        return
        
    if receiver.bot:
        await ctx.send("‚ùå **Tu ne peux pas donner des pi√®ces √† un bot !**")
        return

    try:
        # V√©rifier le solde avant le transfert
        giver_balance = await database.get_balance(giver.id)
        if giver_balance < amount:
            await ctx.send(f"‚ùå **Solde insuffisant !**\nTu as {giver_balance:,} pi√®ces mais tu essayes de donner {amount:,} pi√®ces.")
            return

        # Effectuer le transfert
        success = await database.transfer(giver.id, receiver.id, amount)
        
        if success:
            embed = discord.Embed(
                title="üí∏ Transfert r√©ussi !",
                description=f"**{giver.display_name}** a donn√© **{amount:,}** pi√®ces √† **{receiver.display_name}**",
                color=0x00ff00
            )
            embed.set_footer(text=f"Nouveau solde de {giver.display_name}: {giver_balance - amount:,} pi√®ces")
            await ctx.send(embed=embed)
        else:
            await ctx.send("‚ùå **√âchec du transfert. Solde insuffisant.**")
            
    except Exception as e:
        logger.error(f"Erreur give {giver.id} -> {receiver.id}: {e}")
        await ctx.send("‚ùå **Erreur lors du transfert.**")

@bot.command(name='dailyspin', aliases=['daily', 'spin'])
@commands.cooldown(1, 86400, commands.BucketType.user)  # 1 fois par jour
async def dailyspin_cmd(ctx):
    """R√©cup√®re tes pi√®ces quotidiennes"""
    user_id = ctx.author.id
    now = datetime.now(timezone.utc)

    try:
        # V√©rifier le dernier daily
        last_daily = await database.get_last_daily(user_id)
        
        if last_daily:
            delta = now - last_daily
            if delta.total_seconds() < 86400:
                remaining = 86400 - delta.total_seconds()
                hours = int(remaining // 3600)
                minutes = int((remaining % 3600) // 60)
                
                embed = discord.Embed(
                    title="‚è∞ Daily d√©j√† r√©cup√©r√© !",
                    description=f"Tu pourras r√©cup√©rer ton daily dans **{hours}h {minutes}min**",
                    color=0xff9900
                )
                await ctx.send(embed=embed)
                return

        # G√©n√©rer la r√©compense
        base_reward = random.randint(50, 150)
        bonus_chance = random.randint(1, 100)
        
        # Chance de bonus (10% de chance)
        if bonus_chance <= 10:
            bonus = random.randint(50, 200)
            total_reward = base_reward + bonus
            bonus_text = f"\nüéâ **BONUS:** +{bonus} pi√®ces !"
        else:
            total_reward = base_reward
            bonus_text = ""

        # Mettre √† jour la base de donn√©es
        await database.update_balance(user_id, total_reward)
        await database.set_last_daily(user_id, now)

        # Afficher le r√©sultat
        embed = discord.Embed(
            title="üé∞ Daily Spin !",
            description=f"**{ctx.author.display_name}** a gagn√© **{total_reward:,}** pi√®ces !{bonus_text}",
            color=0x00ff00
        )
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
        embed.set_footer(text="Reviens demain pour ton prochain daily !")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        logger.error(f"Erreur dailyspin pour {user_id}: {e}")
        await ctx.send("‚ùå **Erreur lors du daily spin.**")

@bot.command(name='leaderboard', aliases=['top', 'rich', 'lb'])
async def leaderboard_cmd(ctx, limit: int = 10):
    """Affiche le classement des plus riches"""
    if limit > 20:
        limit = 20
    elif limit < 1:
        limit = 10

    try:
        top_users = await database.get_top_users(limit)
        
        if not top_users:
            await ctx.send("‚ùå **Aucun utilisateur trouv√© dans le classement.**")
            return

        embed = discord.Embed(
            title="üèÜ Classement des plus riches",
            color=0xffd700
        )

        description = ""
        for i, (user_id, balance) in enumerate(top_users, 1):
            try:
                user = bot.get_user(user_id) or await bot.fetch_user(user_id)
                username = user.display_name if user else f"Utilisateur {user_id}"
            except:
                username = f"Utilisateur {user_id}"

            # Emojis pour le podium
            if i == 1:
                emoji = "ü•á"
            elif i == 2:
                emoji = "ü•à"
            elif i == 3:
                emoji = "ü•â"
            else:
                emoji = f"`{i:2d}.`"

            description += f"{emoji} **{username}** - {balance:,} pi√®ces\n"

        embed.description = description
        embed.set_footer(text=f"Top {len(top_users)} utilisateurs")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        logger.error(f"Erreur leaderboard: {e}")
        await ctx.send("‚ùå **Erreur lors de l'affichage du classement.**")

# ==================== COMMANDES ADMIN ====================

@bot.command(name='addmoney', aliases=['addbal'])
@commands.is_owner()
async def addmoney_cmd(ctx, member: discord.Member, amount: int):
    """[OWNER] Ajoute des pi√®ces √† un utilisateur"""
    try:
        await database.update_balance(member.id, amount)
        embed = discord.Embed(
            title="üí∞ Argent ajout√©",
            description=f"**{amount:,}** pi√®ces ajout√©es √† **{member.display_name}**",
            color=0x00ff00
        )
        await ctx.send(embed=embed)
    except Exception as e:
        logger.error(f"Erreur addmoney: {e}")
        await ctx.send("‚ùå **Erreur lors de l'ajout d'argent.**")

@bot.command(name='setmoney', aliases=['setbal'])
@commands.is_owner()
async def setmoney_cmd(ctx, member: discord.Member, amount: int):
    """[OWNER] D√©finit le solde exact d'un utilisateur"""
    try:
        await database.set_balance(member.id, amount)
        embed = discord.Embed(
            title="üí∞ Solde d√©fini",
            description=f"Solde de **{member.display_name}** d√©fini √† **{amount:,}** pi√®ces",
            color=0x00ff00
        )
        await ctx.send(embed=embed)
    except Exception as e:
        logger.error(f"Erreur setmoney: {e}")
        await ctx.send("‚ùå **Erreur lors de la d√©finition du solde.**")

# ==================== COMMANDE D'AIDE ====================

@bot.command(name='help', aliases=['h', 'aide'])
async def help_cmd(ctx):
    """Affiche l'aide du bot √©conomie"""
    embed = discord.Embed(
        title="ü§ñ Bot √âconomie - Aide",
        description="Voici toutes les commandes disponibles :",
        color=0x0099ff
    )

    # Commandes principales
    embed.add_field(
        name="üí∞ Commandes √âconomie",
        value=f"`{PREFIX}balance [@user]` - Affiche le solde\n"
              f"`{PREFIX}give <@user> <montant>` - Donne des pi√®ces\n"
              f"`{PREFIX}dailyspin` - Daily spin (50-150 pi√®ces)\n"
              f"`{PREFIX}leaderboard [limite]` - Top des plus riches",
        inline=False
    )

    # Aliases
    embed.add_field(
        name="üîÑ Aliases",
        value="`balance` ‚Üí `bal`, `money`\n"
              "`give` ‚Üí `pay`, `transfer`\n"
              "`dailyspin` ‚Üí `daily`, `spin`\n"
              "`leaderboard` ‚Üí `top`, `rich`, `lb`",
        inline=False
    )

    embed.set_footer(text=f"Pr√©fixe: {PREFIX} | D√©velopp√© avec discord.py")
    embed.set_thumbnail(url=bot.user.display_avatar.url)

    await ctx.send(embed=embed)

# ==================== √âV√âNEMENTS ADDITIONNELS ====================

@bot.event
async def on_guild_join(guild):
    """√âv√©nement quand le bot rejoint un serveur"""
    logger.info(f"‚úÖ Bot ajout√© au serveur: {guild.name} ({guild.id})")

@bot.event
async def on_guild_remove(guild):
    """√âv√©nement quand le bot quitte un serveur"""
    logger.info(f"‚ùå Bot retir√© du serveur: {guild.name} ({guild.id})")

# ==================== D√âMARRAGE ====================

async def main():
    """Fonction principale pour d√©marrer le bot"""
    try:
        async with bot:
            await bot.start(TOKEN)
    except KeyboardInterrupt:
        logger.info("üëã Arr√™t du bot demand√© par l'utilisateur")
    except Exception as e:
        logger.error(f"üí• Erreur fatale: {e}")
    finally:
        if database.pool:
            await database.close()
            logger.info("üîå Connexion √† la base ferm√©e")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã Au revoir !")
    except Exception as e:
        print(f"üí• Erreur lors du d√©marrage: {e}")